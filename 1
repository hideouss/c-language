#define: macro definition   represent numbers strings expressions  no semicolon 
source code to preprocessor to compiler    processing directives begins a # symbol
#include preprocessor  replace line with header file contents 
macro is a fragment of code is given a name       function-like macros
conditional compilation(#ifdef #if #defined #else #elseif): if statement is tested whether excute a block code when excuting 
conditional compilation used to include/skip a block code before execute       conditional codes
static variable syntax:static data_type var_name = var_value     static variable remains in memroy while prohgram is running 
normal variable or auto variable is destroyed when a function call where variable declare is over   initial static variable
standard predefined macro: name all start with double underscores   
assign operator: assign a value to a variable (= += -= *= /= %=)
data type:unsigned long  unsigned int 
pointer store variable address or memory location    unary operator &:return variable adderss    &var     
variable address is chaging when each running  
unary operator *(asterisk):declare pointer variable  when pointer declared must has a * before its name   access value (dereference)
add 2 addresses no sense     subtract 2 addresses show the 2 addressed offset     *&var
pointer arithmetic is meaningless only apply on an array     pointer and multi dimen array
pointer to variable:pointer and value pointed by pointer both stored in read-write area   could change ptr value and object value
ptr pointing to     pointer could chage pointed object value 
pointer to constant:const int *ptr;/int const *ptr;  could change pointer to any other integer variable cannot change
the object value pointer pointing to     pointer is stored in read-write area    object_pointed in read-only area/read-write area
pointer cannot change pointed object value 
constant pointer to variable:int *const ptr(constant pointer to an int pointer) could change objectvalue pointed 
cannot change pointer to point another variable 
constant pointer to constant:const int *const ptr:a constant pointer to a constant variable
cannot change object value pointed by pointer  cannot point to another variable
use pointer ability could create different data structure   different ways to organize data in memory 
function declare:return_type function_name(parameters);parameters name not important in function declare only parameters type
is important   when define a function in one souce file then call the function in another file will need function declare before
call the function
function define:return_type function_name(parameters) {}    function define need parameter type 
call function:need function name and function arguments  if function return a value could store that value
formal parameters:behave like local variable live inside function    actual argument
parameters and argument:
call by value:parameter change cannot change argument    call by reference:parameter change could change argument 
function parameter:
arrow operator:->  access element in structure and union  it access struct/union member that pointer point to  
a pointer variable point to a structure or union   
no stadard syntax only has a good concept not has a good syntax  concept decide syntax
header file
function pointer: store function address in pointer variable 
array:element sets stored in continuous memory location 
access structure member:member access operator(.) 
define structure:struct [structure tag] {menber definitions;}[structure variables]; 
use keyword structure define variables of structure type 
structure as function parameter      structure pointer as function parameter
define pointer to structure as define pointer to any other variable
static function:function in c default scope is global    static function restrict its scope in contained this function file
pointer->struct/union member
static variable;static function;
structure nest could be extended to any level:access inner structure member write a outer stucture variable followed by .
and followed by inner structure variable followed by . followed by member name 
function return structure;function return structure pointer;
if statement:if (expression) {}    expression:true/false    expression in parentheses
if statement nest:if (expression) {if (expression) {}}
if else statement:if (expression) {} else {} 
if else nest:if (expression) {if (expression) {} else {}} else {}
is else ladder:if (expression) {} else if (expression) {} esle if (expression) {} else(expression) {}
goto statement:goto label; ... ...label:statement;  
constant structure;static structure;structure nest;
custom data type:
pointer point to which data type/variable is which data type      data name is not vital   data type is very important
void pointer as function parameter;
declare a structure pointer: struct structure_name *structure_pointer_variable;       struct(keyword) 
initial structure pointer: structure_pointer_variable = &structure_variable;
access structure member via structure pointer: structure_pointer_variable -> member_name; 
constant structure pointer as function parameter;
!: unary reverse logical operator;operator precedence;true:non_zero  false:zero;
logical operator:&&(and operator)  ||(or operator)  !(not operator)
& operator:return address; * operator:return address value;
conditonal compilation: #ifdef macro_definition    #ifdef directive must be closed by an #endif directive




 

















